# ---------------------------------------------------
# Name : Zamam Moeez
# ID: 1665264
# CMPUT 274 , Fall 2021
#
# Exercise 2: Unfair Dice
# ---------------------------------------------------


def biased_rolls(prob_list, s, n):
    """ Simulate n rolls of a biased m-sided die and return
    a list containing the results.

    Arguments:
        prob_list: a list of the probabilities of rolling the
                   number on each side of the m-sided die. The list
                   will always have the length m (m >= 2), where m is
                   the number of sides numbered 1 to m. Therefore,
                   for example, the probability stored at index 0 in
                   the list is the probability of rolling a 1 on
                   the m-sided die.
        s: the seed to use when initializing the PRNG
        n: the number of rolls to return

    Return:
        rolls: a list (of length n) containing each of the n rolls of the
               biased die, in the order they were generated.
    """

    # import random module

    import random

    # initialize PRNG with input seed value 's'

    random.seed(s)
    
    # define the results of each roll as an empty array called 'rolls'

    rolls = []
    
    # employ use of for loop and iterate over prob_list

    for i in range(1, len(prob_list)):
    
    # compute the cumulative probability such that the last element
    #  in prob_list is 1

        prob_list[i] = prob_list[i] + prob_list[i - 1]

    # iterate over the number of rolls

    for i in range(n):

    # compute randomn probability using the randomn module in range 0-1
    # and assign variable 'probin'

        probin = random.random()

    # iterate over prob_list

        for j in range(len(prob_list)):

    # if the probability value within prob_list is > than
    # the probin value then it is the side that occurs

            if prob_list[j] > probin:

    # apprend the value of the biased side to the rolls array
                
                rolls.append(j + 1)

    # break to prevent each following side from being appended to the array
                
                break
    # return rolls as defined in function description
    
    return rolls


def draw_histogram(m, rolls, width):
    """ Draws a frequency histogram of the rolls of an m-sided die
    mapped to a fixed width.

    Arguments:
        m (int): the number of sides on the die
        rolls (list): the list of rolls generated by the biased die
        width (int): the fixed width of the histogram, in characters
                     (this is the length of the longest bar in the
                     histogram, to maximize space in the chart)

    Returns:
        None (but prints the histogram to standard output)
    """
    # initialize array to collect the number of occurences
    # of each number
    
    occ = []
    
    # iterate through the number of sides of the die 'm'
    
    for i in range(m):
    
    # append the occurences of each number to occ using 
    # the count funtion to find the number of occurences
        
        occ.append(rolls.count(i+1))
    
    # compute the scaling factor by finding how many hastags
    # each occurence is worth
    
    scale = width/max((occ))
    
    # initialize the array containing the numbers of hastags
    # for each side as an empty array
    
    hasht = []
    
    # iterate over occ array
    
    for i in range(0, len(occ)):
    
    # append value of number of arrays for each side to the
    # hast array by multiplying the scale to the value of number
    # of occurences
        
        hasht.append(round((occ[i]*scale)))
    
    # print header
    
    print("Frequency Histogram: " + str(m) + "-sided Die")
    
    # iterate over number of sides m
    
    for j in range(0, m):
    
    # format string such that the number of hashtags printed correponds to the
    # value within array hasht and number of dashes corresponds to the remaining
    # positions that must be filled = width - hasht[i]
        
        print("{j}".format(j=j+1) + "." + "#"*hasht[j] + "-"*(width-hasht[j]))


if __name__ == "__main__":
    # Any code indented under this line will only be run
    # when the program is called directly from the terminal
    # using "python3 unfairDice.py". This can be useful for
    # testing your implementations.
    pass
